28min

## 1. 自我介绍

## 2. 介绍一下项目里面的难点

## 3. 性能优化方案

说首屏加载优化的时候，可以从 【用户输入URL到页面渲染】 这一问题开始解释，每一步所需要做的优化

* DNS与解析  dns-prefetch

* 缓存

【开启http2】

* http2采用二进制分帧，相比于http1.x的文本效率更高

* 多路复用：建立一个TCP通道，请求和响应可以同时基于这个通道进行双向通信

* 首部压缩：节省消息头占用的网络的流量，比如第二次请求只需要发送请求头差异的部分，就可以减少冗余，降低开销

* 服务端推送：可以直接将相关资源直接推送，无需请求，大大减少了多次请求的耗时

【浏览器缓存】

合理使用缓存相关响应头，比如第三方库和业务代码分开打包（webpack代码分离），防止每次都需要重复加载第三方库

【webpack代码分离、tree shaking（无用代码丢弃）】

需要根据具体业务情况，以及引入的第三方库，具体考虑如何拆包。比如引入vue和Echarts，vue是所有页面都需要的基础库，而echarts是其他页面特殊需要的特殊库，因此可以将其分别拆包

【懒加载】

首屏不需要的部分的逻辑代码，将其拆分并懒加载

【其它常见方案】

* 图片懒加载

* 资源压缩

* cdn

* 雪碧图


## 4. 闭包

函数 + 函数体内可访问的变量总和

和作用域有关，JavaScript执行过程中会创建可执行上下文，可执行上下文中的词法环境中含有外部词法环境的引用。

## 5. 原型链

## 6. 事件流

* 如何阻止冒泡？除了stopPropagation()还有别的吗？
这个目前真的没有找到其它的阻止冒泡的方法

## 7. v-if 和 v-show

## 8. v-for 的 key ？

## 9. 小程序和vue区别

1. 响应式实现

【小程序】
* 是单向的数据传递，而且是采用双线程的视图层（WebView）和逻辑层（JSCore），当数据改动需要同步到视图层的时候，需要通过小程序客户端来传递
* 逻辑层发送网络请求也需要由Native转发
* 数据需要转化成字符串形式传递，因此数据到达图层并不是实时的，所以使用setData函数将数据从逻辑层发送到视图层，是异步的，因此频繁调用setData()会造成问题

【Vue】
* 通过defineproperty实现双向绑定，视图层和逻辑层可以双向更新
* 其它响应式相关……

2. 生命周期

【小程序】
* onLaunch： 小程序启动
* onLoad：页面创建时执行
* onShow：页面出现在前台时执行
* onHide：页面出现在后台时执行
* onReady：页面初次渲染完成

【Vue】
* created之前：响应式双向绑定 完成依赖收集
* beforeMount之前：分三个阶段编译template。parse解析构建AST语法树，optimize标记静态节点，generate生成render function三个阶段
* beforeUpdate之前：虚拟DOM和patch之前的阶段，patch机制，diff算法。nextTick异步队列将连续更新DOM积攒一起更新（ 事件循环，setTimeout(func, 0) ）

## 10. 标准盒模型 和 IE盒模型

## 11. 浮动元素水平垂直居中 ？

flex布局

## 12. 清除浮动的几种方式 ？

* clear:both  （一般使用clearfix，因为不会增加没有意义的标签）
* BFC
* 父元素加一个类 clearfix（比较全面的兼容）
```css
.clearfix :after {
  clear: both;
  content: '.';
  display: block;
  width: 0;
  height: 0;
  visibility: hidden;
}

```

## 13. 一面的的问题  CSS 和 @import 区别 ？
